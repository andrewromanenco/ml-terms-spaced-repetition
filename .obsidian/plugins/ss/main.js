/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/kv-synced/dist/lww-version.js
var require_lww_version = __commonJS({
  "node_modules/kv-synced/dist/lww-version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LWWVersionHandler = void 0;
    var LWWVersionHandler2 = class {
      constructor(timestampSuppier = () => {
        return new Date().toISOString();
      }) {
        this.timestampSuppier = timestampSuppier;
      }
      stampNewRecord(values) {
        return {
          "timestamp": this.timestampSuppier()
        };
      }
      stampExistingRecord(values, currentVersion) {
        return {
          "timestamp": this.timestampSuppier()
        };
      }
      handleConflict(key, one, two) {
        const date1 = new Date(one.version["timestamp"]);
        const date2 = new Date(two.version["timestamp"]);
        return date1 > date2 ? one : two;
      }
    };
    exports.LWWVersionHandler = LWWVersionHandler2;
  }
});

// node_modules/kv-synced/dist/kv.js
var require_kv = __commonJS({
  "node_modules/kv-synced/dist/kv.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LWWVersionHandler = exports.KV = void 0;
    var KV2 = class {
      constructor(cloudDrive, versionHandler) {
        this.cloudDrive = cloudDrive;
        this.versionHandler = versionHandler;
        this.cleanRecords = {};
        this.dirtyRecords = {};
      }
      load() {
        return __awaiter(this, void 0, void 0, function* () {
          const list = yield this.cloudDrive.list();
          for (let i = 0; i < list.length; i++) {
            const file = list[i];
            const content = yield this.cloudDrive.read(file);
            const storedKVList = JSON.parse(content);
            for (const key in storedKVList) {
              const value = storedKVList[key];
              if (key in this.cleanRecords) {
                this.cleanRecords[key] = this.versionHandler.handleConflict(key, this.cleanRecords[key], value);
              } else {
                this.cleanRecords[key] = value;
              }
            }
          }
          yield this.compactDB(list);
        });
      }
      compactDB(listOfFile) {
        return __awaiter(this, void 0, void 0, function* () {
          if (listOfFile.length >= KV2.COMPACT_LIMIT) {
            const jsonString = JSON.stringify(this.cleanRecords);
            yield this.cloudDrive.write(jsonString);
            for (let i = 0; i < listOfFile.length; i++) {
              const file = listOfFile[i];
              yield this.cloudDrive.delete(file);
            }
          }
        });
      }
      get(key) {
        if (key in this.dirtyRecords) {
          return this.dirtyRecords[key].values;
        }
        if (key in this.cleanRecords) {
          return this.cleanRecords[key].values;
        }
        return void 0;
      }
      put(key, values) {
        if (key in this.cleanRecords) {
          const existingRecord = this.cleanRecords[key];
          delete this.cleanRecords[key];
          this.dirtyRecords[key] = {
            values,
            version: this.versionHandler.stampExistingRecord(values, existingRecord.version)
          };
        } else {
          this.dirtyRecords[key] = {
            values,
            version: this.versionHandler.stampNewRecord(values)
          };
        }
      }
      commit() {
        return __awaiter(this, void 0, void 0, function* () {
          if (Object.keys(this.dirtyRecords).length == 0) {
            return;
          }
          const jsonString = JSON.stringify(this.dirtyRecords);
          yield this.cloudDrive.write(jsonString);
          Object.keys(this.dirtyRecords).forEach((key) => {
            this.cleanRecords[key] = this.dirtyRecords[key];
          });
          this.dirtyRecords = {};
        });
      }
      size() {
        return Object.keys(this.cleanRecords).length + Object.keys(this.dirtyRecords).length;
      }
    };
    exports.KV = KV2;
    KV2.COMPACT_LIMIT = 10;
    var lww_version_1 = require_lww_version();
    Object.defineProperty(exports, "LWWVersionHandler", { enumerable: true, get: function() {
      return lww_version_1.LWWVersionHandler;
    } });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SimplySpaced
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_kv_synced = __toESM(require_kv());

// spacer.ts
function getNextInterval(answer, repetiotions, easyFactor, previousInterval) {
  const newEF = Math.max(1.3, easyFactor + 0.1 - (5 - answer) * (0.08 + (5 - answer) * 0.02));
  if (answer == 0) {
    return {
      easyFactor: 1.3,
      intervalInDays: 1,
      shceduledAt: createDateWithInterval(1),
      repetiotions: 0
    };
  }
  if (answer < 3) {
    return {
      easyFactor: newEF,
      intervalInDays: 1,
      shceduledAt: createDateWithInterval(1),
      repetiotions: 0
    };
  }
  if (repetiotions == 0 && answer == 5 /* PERFECT */) {
    const interval = getRandomInt(5) + 5;
    return {
      easyFactor: newEF,
      intervalInDays: interval,
      shceduledAt: createDateWithInterval(interval),
      repetiotions: 1
    };
  }
  if (repetiotions == 0) {
    const interval = getRandomInt(2) + 1;
    return {
      easyFactor: newEF,
      intervalInDays: interval,
      shceduledAt: createDateWithInterval(interval),
      repetiotions: 1
    };
  } else if (repetiotions == 1) {
    const interval = getRandomInt(5) + 4;
    return {
      easyFactor: newEF,
      intervalInDays: interval,
      shceduledAt: createDateWithInterval(interval),
      repetiotions: 2
    };
  } else {
    const newInterval = Math.round(previousInterval * newEF);
    const jitter = Math.ceil(newInterval * 0.2);
    const randomizedInterval = Math.max(1, Math.round(newInterval - jitter / 2 + getRandomInt(jitter + 1)));
    return {
      easyFactor: newEF,
      intervalInDays: randomizedInterval,
      shceduledAt: createDateWithInterval(randomizedInterval),
      repetiotions: repetiotions + 1
    };
  }
}
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}
function createDateWithInterval(intervalInDays) {
  const date = new Date();
  date.setDate(date.getDate() + intervalInDays);
  date.setHours(0, 0, 0, 0);
  return date;
}

// learning-session.ts
var LearningSession = class {
  constructor(kvs, allMDFiles) {
    this.newCards = [];
    this.todayAndLateCards = [];
    this.todayCardsCount = 0;
    this.lateCardsCount = 0;
    this.kvs = kvs;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayCards = [];
    const lateCards = [];
    allMDFiles.forEach((f) => {
      const path = f.path;
      if (this.kvs.get(path)) {
        const values = this.kvs.get(path);
        if (values["ignore"]) {
          return;
        }
        const scheduledDate = new Date(values["scheduledAt"]);
        if (this.isToday(scheduledDate)) {
          todayCards.push(f);
          this.todayCardsCount++;
        } else if (this.isInThePast(scheduledDate)) {
          lateCards.push(f);
          this.lateCardsCount++;
        }
      } else {
        this.newCards.push(f);
      }
    });
    this.newCards.sort(() => Math.random() - 0.5);
    lateCards.sort(() => Math.random() - 0.5);
    todayCards.sort(() => Math.random() - 0.5);
    this.todayAndLateCards.push(...lateCards);
    this.todayAndLateCards.push(...todayCards);
  }
  isToday(date) {
    const today = new Date();
    return date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate();
  }
  isInThePast(date) {
    const now = new Date();
    return date < now;
  }
  hasMoreCards() {
    return this.newCards.length > 0 || this.todayAndLateCards.length > 0;
  }
  currentCard() {
    if (this.todayAndLateCards.length > 0) {
      return this.todayAndLateCards[0];
    }
    return this.newCards[0];
  }
  currentRepetitions() {
    const path = this.currentCard().path;
    if (this.kvs.get(path) && this.kvs.get(path)["repetiotions"]) {
      return +this.kvs.get(path)["repetiotions"];
    }
    return 0;
  }
  currentEasyFactor() {
    const path = this.currentCard().path;
    if (this.kvs.get(path) && this.kvs.get(path)["easyFactor"]) {
      return +this.kvs.get(path)["easyFactor"];
    }
    return 2.5;
  }
  currentInterval() {
    const path = this.currentCard().path;
    if (this.kvs.get(path) && this.kvs.get(path)["intervalInDays"]) {
      return +this.kvs.get(path)["intervalInDays"];
    }
    return 0;
  }
  updateCard(easyFactor, intervalInDays, repetiotions, scheduledAt) {
    this.kvs.put(this.currentCard().path, {
      "repetiotions": "" + repetiotions,
      "easyFactor": "" + easyFactor,
      "scheduledAt": "" + scheduledAt.toISOString(),
      "intervalInDays": "" + intervalInDays
    });
    this.moveToNextCard();
  }
  ignoreCard() {
    this.kvs.put(this.currentCard().path, {
      "ignore": "true"
    });
    this.moveToNextCard();
  }
  skipCard() {
    this.moveToNextCard();
  }
  punt(toDate) {
    this.kvs.put(this.currentCard().path, {
      "scheduledAt": toDate.toISOString()
    });
    this.moveToNextCard();
  }
  moveToNextCard() {
    if (this.todayAndLateCards.length > 0) {
      this.todayAndLateCards.shift();
      if (this.lateCardsCount > 0) {
        this.lateCardsCount--;
      } else {
        this.todayCardsCount--;
      }
    } else {
      this.newCards.shift();
    }
  }
  getTodaysCount() {
    return this.todayCardsCount;
  }
  getLateCount() {
    return this.lateCardsCount;
  }
  getNewCount() {
    return this.newCards.length;
  }
  again() {
    if (this.todayAndLateCards.length == 0) {
      const card = this.newCards.shift();
      this.newCards.splice(Math.min(10, this.newCards.length), 0, card);
    } else {
      if (this.lateCardsCount > 0) {
        const card = this.todayAndLateCards.shift();
        this.todayAndLateCards.splice(Math.min(10, this.lateCardsCount), 0, card);
      } else {
        const card = this.todayAndLateCards.shift();
        this.todayAndLateCards.splice(Math.min(10, this.todayAndLateCards.length), 0, card);
      }
    }
  }
};

// obsidian-fs.ts
var import_obsidian = require("obsidian");
var _ObsidianFS = class {
  constructor(vault) {
    this.vault = vault;
  }
  async init(app) {
    const vault = app.vault;
    try {
      await vault.createFolder(_ObsidianFS.FOLDER);
    } catch (error) {
    }
  }
  async list() {
    const result = [];
    const folder = this.vault.getAbstractFileByPath(_ObsidianFS.FOLDER);
    import_obsidian.Vault.recurseChildren(folder, (file) => {
      if (file instanceof import_obsidian.TFile) {
        result.push(file);
      }
    });
    return new Promise((resolve) => {
      resolve(result);
    });
  }
  async read(fileHandle) {
    const readValue = await this.vault.read(fileHandle);
    return new Promise((resolve) => {
      resolve(readValue);
    });
  }
  async write(content) {
    const hex = await this.sha256(content);
    const fileName = `${_ObsidianFS.FOLDER}/${hex}.json`;
    try {
      await this.vault.create(fileName, content);
    } catch (error) {
      alert("Error saving updates: " + error);
    }
  }
  async delete(fileHandle) {
    await this.vault.delete(fileHandle);
  }
  async sha256(message) {
    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
};
var ObsidianFS = _ObsidianFS;
ObsidianFS.FOLDER = "ZSpacedRepetition";

// main.ts
var SimplySpaced = class extends import_obsidian2.Plugin {
  async onload() {
    const ribbonIconEl = this.addRibbonIcon("align-vertical-space-between", "Simply spaced", (evt) => {
      new QnAModal(this.app, this).open();
    });
    ribbonIconEl.addClass("my-plugin-ribbon-class");
  }
  onunload() {
  }
};
var QnAModal = class extends import_obsidian2.Modal {
  constructor(app, parentComponent) {
    super(app);
    this.parentComponent = parentComponent;
    this.vault = this.app.vault;
    this.updatedCardsCount = 0;
  }
  async onOpen() {
    const fs = new ObsidianFS(this.vault);
    await fs.init(this.app);
    this.kvs = new import_kv_synced.KV(fs, new import_kv_synced.LWWVersionHandler());
    await this.kvs.load();
    const allMDs = this.vault.getMarkdownFiles();
    this.learningSession = new LearningSession(this.kvs, allMDs);
    const { contentEl } = this;
    this.titleEl.innerHTML += "<h4>Simply spaced</h4>";
    this.root = this.contentEl.createDiv();
    this.doNext();
  }
  doNext() {
    while (this.root.hasChildNodes()) {
      this.root.removeChild(this.root.firstChild);
    }
    if (this.learningSession.hasMoreCards()) {
      this.doNextCard();
    } else {
      this.done();
    }
  }
  async doNextCard() {
    const cardsCountDiv = document.createElement("div");
    if (this.learningSession.getLateCount() == 0) {
      cardsCountDiv.setText(`Today: ${this.learningSession.getTodaysCount()}; New: ${this.learningSession.getNewCount()}`);
    } else {
      cardsCountDiv.setText(`Today: ${this.learningSession.getTodaysCount() + this.learningSession.getLateCount()} (Late: ${this.learningSession.getLateCount()}); New: ${this.learningSession.getNewCount()}`);
    }
    const questionDiv = document.createElement("div");
    const b = document.createElement("b");
    questionDiv.appendChild(b);
    b.setText(this.learningSession.currentCard().basename);
    const questionControlDiv = document.createElement("div");
    const answerDiv = document.createElement("div");
    const answerControlDiv = document.createElement("div");
    this.root.appendChild(cardsCountDiv);
    this.root.appendChild(document.createElement("hr"));
    this.root.append(questionDiv);
    this.root.append(answerDiv);
    this.root.appendChild(document.createElement("hr"));
    this.root.append(questionControlDiv);
    const showAnswerBtn = document.createElement("button");
    showAnswerBtn.setText("Show answer");
    showAnswerBtn.addEventListener("click", async () => {
      this.root.removeChild(questionControlDiv);
      this.root.append(answerDiv);
      this.root.append(answerControlDiv);
      import_obsidian2.MarkdownRenderer.renderMarkdown(await this.vault.read(this.learningSession.currentCard()), answerDiv, "", this.parentComponent);
    });
    questionControlDiv.appendChild(showAnswerBtn);
    const punt3Btn = document.createElement("button");
    punt3Btn.setText("Punt 3");
    punt3Btn.addEventListener("click", () => {
      this.learningSession.punt(createDateWithInterval(3));
      this.doNext();
    });
    answerControlDiv.appendChild(punt3Btn);
    const punt5Btn = document.createElement("button");
    punt5Btn.setText("Punt 5");
    punt5Btn.addEventListener("click", () => {
      this.learningSession.punt(createDateWithInterval(5));
      this.doNext();
    });
    answerControlDiv.appendChild(punt5Btn);
    const notThisSessionBtn = document.createElement("button");
    notThisSessionBtn.setText("Not right now");
    notThisSessionBtn.addEventListener("click", () => {
      this.learningSession.skipCard();
      this.doNext();
    });
    answerControlDiv.appendChild(notThisSessionBtn);
    const ignoreBtn = document.createElement("button");
    ignoreBtn.setText("Ignore forever");
    ignoreBtn.addEventListener("click", () => {
      this.learningSession.ignoreCard();
      this.doNext();
    });
    answerControlDiv.appendChild(ignoreBtn);
    const againBtn = document.createElement("button");
    againBtn.setText("Again");
    againBtn.addEventListener("click", () => {
      this.learningSession.again();
      this.doNext();
    });
    answerControlDiv.appendChild(againBtn);
    this.createAnswerButton(answerControlDiv, 0 /* BLACK_OUT */, "No clue");
    this.createAnswerButton(answerControlDiv, 1 /* WRONG */, "Wrong");
    this.createAnswerButton(answerControlDiv, 2 /* WRONG_EASY_RECALL */, "Wrong, but easy recall");
    this.createAnswerButton(answerControlDiv, 3 /* CORRECT_LOTS_OF_THINKING */, "Right, lots of thinking");
    this.createAnswerButton(answerControlDiv, 4 /* GOOD_SOME_THINKING */, "Right, some hesitation");
    this.createAnswerButton(answerControlDiv, 5 /* PERFECT */, "Perfect");
  }
  createAnswerButton(container, answer, text) {
    const nextIter = getNextInterval(answer, this.learningSession.currentRepetitions(), this.learningSession.currentEasyFactor(), this.learningSession.currentInterval());
    const btn = document.createElement("button");
    btn.setText(`${text}(${nextIter.intervalInDays})`);
    btn.addEventListener("click", () => {
      this.learningSession.updateCard(nextIter.easyFactor, nextIter.intervalInDays, nextIter.repetiotions, nextIter.shceduledAt);
      this.updatedCardsCount++;
      if (this.updatedCardsCount > 10) {
        this.updatedCardsCount = 0;
        this.kvs.commit();
      }
      this.doNext();
    });
    container.appendChild(btn);
  }
  done() {
    this.root.setText("All done");
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    await this.kvs.commit();
  }
};
